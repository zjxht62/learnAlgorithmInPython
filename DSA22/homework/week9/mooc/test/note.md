![img.png](img.png)
+ 冒泡排序
  + 算法过程总共需要n-1趟，随着趟数的增加，**比对**次数逐步从n-1减小到1，并包括可能发生的数据项**交换**
    + 比对次数是：1~n-1的累加：(n-1)*n/2=1/2*n^2-1/2n
    + 对比的时间复杂度**O(n^2)**
    + 
    + 关于交换次数，时间复杂度也是O(n^2)，通常每次交换包括3次赋值操作
      + **最好**情况下，列表已经有序，交换次数为0
      + **最差**情况下，每次比对都要交换，交换次数等于比对次数
      + **平均**情况下，是最差情况的一半
    * 所以，综合起来，冒泡排序算法的
      * 时间复杂度：O(n^2)
      * 空间复杂度：O(1)

+ 选择排序
  + 选择排序的时间复杂度比起冒泡排序稍优
    + 对比次数不变，还是O(n^2)
    + 交换次数则减少为O(n)
  + 所以，选择排序的
    * 时间复杂度：O(n^2)
    * 空间复杂度：O(1)
+ 冒泡排序和选择排序
  + 时间复杂度相同：O(n^2)
  + 空间复杂度相同：都无需额外的空间，所以其空间复杂度为O(1)

![img_1.png](img_1.png)
+ 归并排序
  + 时间复杂度
    + 将归并排序分为两个过程来分析：**分裂** 和 **归并**
    + 分裂的过程，借鉴二分查找中的分析结果，是对数复杂度，时间复杂度为O(logn)
    + 归并的过程，相对于分裂的每个部分，其所有数据项都会被比较和放置一次，所以是线性复杂度，其时间复杂度是O(n)
      + 综合考虑，每次分裂的部分都进行一次O(n)的数据归并，总的时间复杂度是O(n*logn)
  + 空间复杂度
    + 在合并操作中，需要创建一个临时数组来存储两个有序子数组的合并结果。临时数组的长度与待排序数组的长度相同，因此合并操作的空间复杂度为O(n)。
+ 快速排序
  + 时间复杂度
    + 如果分裂**总能**把数据表分为**相等**的**两部分**，那么就是O(logn)的复杂度
    + 而移动需要将每项与中值进行比对，还是O(n)
    + 综合起来就是O(n*logn)
    + 但是，如果不那么幸运的话，中值所在的分裂点过于偏离中部，造成左右两部分数量不平衡
    + 极端情况，有一部分始终没有数据，这样，时间复杂度就会退化到O(n^2)
  + 空间复杂度
    + 在算法运行中不需要额外的存储空间，所以空间复杂度是O(1)