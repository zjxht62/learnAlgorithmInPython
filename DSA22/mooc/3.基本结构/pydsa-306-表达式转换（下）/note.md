## 通用的中缀转后缀算法
对于中缀表达式`A+B*C`，对应的后缀表达式为`ABC*+`可见：
+ 操作数的顺序没有改变
+ 操作符的出现顺序，在后缀表达式中反转了
+ 由于*的优先级比+高，所以后缀表达式中操作符的出现顺序与运算次序一致

**在中缀表达式转换为后缀表达式时，操作符要比操作数晚一些输出**  
所以在扫描到对应的第二个操作数之前，需要把操作符先保存起来

**而这些保存起来的操作符，有可能还需要反转次序输出。**  
在A+B*C中，+虽然先出现，但优先级比后面这个*要低，所以它要等*处理完后，才能再处理。

**由于存在这种反转的特性，所以我们考虑使用栈来保存未处理的操作符**

对于有括号的情况，括号内的操作符的优先级被提升了  

**后缀表达式中操作符应该出现在左括号对应的右括号位置**  
所以遇到左括号，要先标记一下，其后面出现的操作符优先级提升了，一旦扫描到对应的右括号，就可以马上输出这个操作符

总结一下，在从左到右逐个字符扫描中缀表达式的过程中，采用一个栈来暂存未处理的操作符。  
这样，栈顶的操作符就是最近暂存进去的，当遇到一个新的操作符，就需要跟栈顶的操作符比较一下优先级，再进行处理

## 通用的中缀转后缀算法：流程
从左到右扫描中缀表达式中的单词列表
+ 如果单词是操作数，那么直接添加到后缀表达式列表的末尾
+ 如果单词是左括号(，则压入opstack栈顶
+ 如果单词是右括号)，则反复弹出opstack栈顶操作符，加入到输出列表末尾，直到遇见左括号
+ 如果单词是操作符*/+-，则压入opstack栈顶
  + 在压入之前，检查其与栈顶操作符的优先级
  + 如果栈顶的高于或等于它，就要反复弹出栈顶操作符，加入到输出列表末尾（也就是说优先级高的操作符需要先输出），直到栈顶的操作符优先级低于它。

扫描结束后，将opstack中的剩余操作符依次弹出，添加到输出列表末尾

把输出列表再用join方法合并成后缀表达式字符串