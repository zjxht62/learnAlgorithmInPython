# 找零兑换问题的动态规划解法
## 找零兑换：动态规划解法
+ 中间结果记录可以很好的解决找零兑换问题
+ 实际上，这种方法还不能称之为动态规划，而是叫做“memoization”（记忆化/函数值缓存）的技术提高了递归解法的性能
![img.png](img.png)
+ 动态规划算法采用了一种**更有条理**的方式来得到问题的解
+ 找零兑换的动态规划从**最简单**的“1分钱找零”的最优解开始，**逐步递加**上去，直到我们需要的找零钱数
+ 在找零递加过程中，**设法保持每一分钱的递加都是最优解**，一直加到求解找零钱数，自然就得到最优解
+ 递加的过程能保持最优解额度**关键**是，其**依赖于**更少钱数最优解的简单计算，而更少钱数的最优解已经得到了
+ **问题的最优解**包含了**更小规模子问题的最优解**，这是一个最优化问题能够用动态规划策略解决的**必要**条件  
originalamount找零兑换问题具体来说就是：
![img_1.png](img_1.png)
+ 采用动态规划来解决11分钱的兑换问题  
从一分钱开始，逐步建立一个兑换表
![img_2.png](img_2.png)
+ 计算11分钱的兑换法，我们做如下几步：  
首先是减去1分硬币，剩下的10分钱查表最优解是1  
然后减去5分硬币，剩下6分钱查表最优解是2  
最后减去10分硬币，剩下一分钱查表最优解是1
+ 通过上述最小值得到最优解：2个硬币
![img_3.png](img_3.png)
## 找零兑换：动态规划代码
```python
# 动态规划求解找零问题
def doChangeInDP(coin_value_list, change, min_coins_list):
    for cents in range(1, change + 1):
        coin_count = cents
        for c in [d for d in coin_value_list if d <= cents]:
            if min_coins_list[cents - c] + 1 < coin_count:
                coin_count = min_coins_list[cents - c] + 1
        min_coins_list[cents] = coin_count

    return min_coins_list[change]


print(doChangeInDP([1, 5, 10, 25], 63, [0] * 64))

```
## 找零兑换：动态规划算法扩展
+ 我们注意到动态规划算法的doChangeInDP其实并不是一个递归函数  
虽然这个问题我们一开始是通过递归解决，但是最终我们找到了一个更高效更有条理的非递归解法
+ 动态规划中最主要的思想是  
从**最简单**情况开始到达所需找零的循环  
其每一步都**依靠以前的最优解**来得到本步骤的最优解，直到得到答案
+ 前面的算法已经得到了最少硬币的数量， 但没有返回硬币如何组合 
+ 扩展算法的思路很简单，只需要在生成最优解列表同时**跟踪记录**所选择的那个硬币币值即可 
+ 在得到最后的解后，减去选择的硬币币值 ，**回溯**到表格之前的部分找零，就能逐步得到每一步所选择的硬币币值
